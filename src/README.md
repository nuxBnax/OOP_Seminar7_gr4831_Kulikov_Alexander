Я немного доработал калькулятор.

1. Класс Text является хорошим примером принципа единственной ответственности, т.к. он отвечает за вывод текстовых 
сообщений в консоль (Single Responsibility Principle).
2. Разные интерфейсы отвечает за разные функции(был 1 общий интерфейс(Data) я его разделил на 2 разных) (Interface Segregation Principle).
Один(Data) интерфейс отвечает за вычислительные операции, а другой (Logger) только за логирование (раньше все было в одном)
3. В Классе Operations используются интерфейсы, которые реализуются в классе Cotroller (Dependency Inversion Principle)
   (Не могу сказать, что данный принцип мою целиком понят).

Примеры принципов Open-Closed Principle и Liskov Substitution Principle у меня отсутствуют, т.к. для их реализации нужны 
классы с наследованием.
Их можно было бы реализовать с числами по примеру numbers является родителем numInt, numDouble и numComplex, но в текущей
реализации они мне показались неуместными и я их убрал за не надобностью.

Для того чтобы реализовать паттерн "Фабрика" я изменил interface Data(в котором были объявлены
разные методы как для целочисленных/дробных вычислений, так и для комплексных) и создал interface 
Calculate (в котором методы сложения, вычитания, умножения и деления будут общими как для целочисленных/дробных вычислений,
так и для комплексных). При этом я поделил класс Function (в нем были методы и для тех и для других) на два отдельных класса
Function(только для вычислений с целочисленными/дробными числами) и FunctionComplex(только для вычислений с комплексными 
числами), которые имплементируют interface Calculate.